## 三维矩阵在opengl中的应用

### opengl中的坐标介绍

#### opengl中的窗口坐标

![](img/xy_window.png)

在opengl中我们所看到窗口如上图所示，是一个以中心为坐标原点，x和y分别从-1到1的一个笛卡尔坐标系。也就意味着，后续我们所讨论的坐标系的范围是[-1,1]

也许，大家在查看其它介绍opengl的书中，经常会有这样的说明，首先我们建立一个长为1920 宽为 1080的窗口，这句话的意思是说，把屏幕 1920 * 1080个像素点映射到 [-1,1] 这个范围内。也正因为如此，这样的窗口坐标，我们称之为 设备化标准坐标系

#### opengl 中的纹理坐标系

![](img/tex_coords.png)

纹理坐标系是一个以左下角为原点，取值范围[0,1]的坐标系

### 窗口坐标系如何和纹理坐标系的关系

$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0\\
 -1.0 & -1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0\\
 1.0 & -1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0\\
 1.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 1.0
 
}
\right]
$$

这是一个 4 * 7 的矩阵 ，接下来我们对于该矩阵的定义做一个说明 (矩阵的定义可以由开发者自行定义，这里采用的是比较传统普遍的定义方式) 

我们可以把这个矩阵看成是由三部分组成，当然这样写只是为了说明方便,实际上这样的表述是错误的:
$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 \\
 -1.0 & -1.0 & 0.0 \\
 1.0 & -1.0 & 0.0 \\
 1.0 & 1.0 & 0.0 
 
}
\right]
\left[
\matrix{
 0.0 & 0.0 & 0.0 \\
  0.0 & 0.0 & 0.0\\
 0.0 & 0.0 & 0.0\\
  0.0 & 0.0 & 0.0
 
}
\right]


\left[
\matrix{
0.0 & 1.0\\
0.0 & 0.0\\
1.0 & 0.0\\
1.0 & 1.0}
\right]
$$
首先我们要解释下这样的一个矩阵的行和列所代表的意义。

行代表物体的一个顶点的综合信息，由于我们绘制的是一个矩形，因而使用4个顶点便可以正确表示(实际在正确的绘制方式之中，由于是以三角形绘制的，需要6个顶点，这里不展开叙述)，由于在图形学中逆时针代表正向，后续所有讨论的顺序，均以该顺序作为标准。

列代表该顶点的一个属性, 可以看到这个矩阵一共有8列，每列分别代表

ox,oy,oz,r,g,b,tx,ty

ox：物体的x轴坐标

oy：物体的y轴坐标

oz:   物体的z轴坐标

r ： 物体的颜色r通道

g :    物体的颜色g通道

b：物体的颜色b通道

tx：纹理x坐标

ty：纹理y坐标

我们回过头看下前面叙述的设备化标准坐标系和纹理坐标系，就可以得到第一行所代表的意义
$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 \\
 }
\right]
$$
物体的左上角顶点和窗口的左上角顶点重合
$$
\left[
\matrix{
 0.0 & 0.0 & 0.0 \\
 }
\right]
$$
该顶点颜色为黑色,alpha信息该矩阵并没有给出，一般该属性会在glsl中进行定义
$$
\left[
\matrix{
0.0 & 1.0\\
}
\right]
$$
该顶点所对应的纹理坐标是(0.0,1.0) 也就是图片的左上角。

同理，其它几行也可以有类似的解释，读者可以尝试自行解释下。

ps: 运行程序看下效果.

### opengl中 图片的旋转 缩放 位移

我们看一下我们设置的window属性 1920 * 1080 

图片的属性 800 * 600 , 如果 按上述的方式设置，则意味着刚开始我们就对图片进行了拉伸使之铺满全屏,如果我们希望得到的效果是 

图片没有拉伸然后展示在图片的中心 或者 左上角，我们如何处理比较合适。

在解决这个问题之前，首先我们要确定一些东西，就是在opengl中，如果我们进行一个旋转，缩放，位移，那么它是什么东西作为参照物的。

在opengl中，我们常用类似于这样的方式进行物体的旋转，缩放和位移

```c++
glm::mat4 trans = glm::mat4(1.0f);
trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
trans = glm::translate(trans, glm::vec3(1.0f, 0.0f, 0.0f));
trans = glm::rotate(trans, glm::radians(45.0f), glm::vec3(0.0f, 0.0f, 1.0f));
```

上面的程序代表一个变化矩阵，如果大家还记得上一讲的内容，还记得这样的一个公式

M3 * M2 * M1 * V =（M3 * M3 * M1） * V

它意味着一个物体在坐标系中的运算，可以看成是物体经过M1，M2，M3三次变换，或者是先把变换进行求积，然后让物体进行一次变换。

在现在的场景中，V 就是我们上面的4*7 矩阵(确切的说是，该矩阵中和坐标有关系的部分)，M3 * M2 * M1 可以看成是trans 发生的一系列变化。

不知道大家看到这个公式后，直观上有哪些疑问？我这边直观的疑问是

1. 该变换所依赖的重心点是什么
2. 每个vec3中所代表的float的定义是什么
3. 如果运算顺序发生改变，我们所得到的结果是什么

为了回答这样的问题，我们做些简单的实验:

#### 原图

![原图](img\origin.bmp)

#### 只有scale

![s](img/s.bmp)

#### 只有Translate

![](img/t.bmp)

#### 只有rotate

![](img/r.bmp)



#### 结论

经过这三轮变化，我们做对比可以得出什么样的结论和认识？

1. 对于缩放来说，它缩放的大小，glm::vec3(0.5f, 0.5f, 0.5f)，中的0.5f指的分别是 x ，y，z 分别缩放到原来的0.5f，且缩放的中心点是图片的原点
2. 对于旋转来说，glm::radians(45.0f), glm::vec3(0.0f, 0.0f, 1.0f)，他所旋转的中心同样是图片的原因，角度逆时针为正45度，依据右手坐标系的原则，以z轴旋转
3. 对于位移来说，glm::vec3(1.0f, 0.0f, 0.0f)，看上去1.0f是窗口的一半，实际上也确实移动了一半。那么是不是可以下决定就是，所谓的平移就是指的是按照窗口的大小进行x/2.0f 的平移呢？

为了验证这个结论是否正确，我们再次做一个程序实验

```c++

glm::mat4 trans = glm::mat4(1.0f);
trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
trans = glm::translate(trans, glm::vec3(0.5f, 0.5f, 0.0f));
```

如果按照前面的推论，现在这样的变化结果应该是 1/4的图片 充满右上角，我们拿程序实验下：

![](img\st_0.5.bmp)

结果和我们预想的不一样，感觉上这个0.5f 应该是图片缩放后的长度和宽度，由于所处在中心位置不太好看出来，因而我们先把图移到左上角，然后在处理。

这里我们修改图片初始的坐标，然后长宽取图片的真实的长宽800*600，因而所需要的矩阵是

```c++

	float trangle[] = {
		//lt color
		-1.0f,1.0f,0.0f,0.0f,0.0f,0.0f,0.0f,1.0f,
		//lb color
		-1.0f,-0.48f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
		//rb color
		0.33f,-0.48f,0.0f,0.0f,0.0f,1.0f,1.0f,0.0f,
		//rt color
		0.33f,1.0f,0.0f,0.0f,0.0f,0.0f,1.0f,1.0f
	};


```



![](img/o.bmp)



我们使用相同变换方法：

```c++
trans = glm::translate(trans, glm::vec3(1.0f, 0.0f, 0.0f));
```



![](img\o_t_1.0x.bmp)





为了，解决弄清楚，translate的含义，我们回忆下上节关于缩放的定义，以(0,0)为原点不变，x，y分别缩小相关倍数。什么意思？

![](img/s_c.bmp)

为了验证我们的结论，我们如果想让图片充满右上角，所需要的位移应该是(1.0f,1.0f)

```c++

glm::mat4 trans = glm::mat4(1.0f);
trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
```

结果验证，证明结果是正确的。

现在我们弄明白了，先scale 在 translate的样式，那么如果我们先 translate，然后在scale 所得到的结果是什么样子的呢？

该结果可以由大家思考，然后得出结论。



由于先translate后，在做变换，会导致原点(0,0)的位置变化，因而在对物体做变形时，我们所采用的方式都是先 scale rotate 最后进行translate，这样是为了让分析任何问题，都基于同一个坐标系去考虑。



### 添加观察矩阵

```c++

gl_Position = view * transform*vec4(aPos,1.0);

```

glsl中的position进行相关性的修改，我们可以看到物体的变换，是否两个矩阵相乘得出。那么，我们针对这种情况，我们需要 思考几个问题：

1. 先在tranform中 scale，再在view中scale，和直接在transform中scale 两次的结果是一致的么？
2. 现在tranform中translate，再在view中translate和，直接在transform中tranlate两次的结果是一致的么？
3. 观察矩阵的中心又在哪里？

```c++

	glm::mat4 trans = glm::mat4(1.0f);
	trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
    glm::mat4 viewMat = glm::mat4(1.0f);
	viewMat = glm::scale(viewMat, glm::vec3(0.5f, 0.5f, 0.5f));

```



```c++
    glm::mat4 trans = glm::mat4(1.0f);
	trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
    trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));


```



scale的结果一致

接下来，我们看下连续translate的情况

```c++
trans = glm::translate(trans, glm::vec3(1.0f, 0.0f, 0.0f));
trans = glm::translate(trans, glm::vec3(0.5f, 0.0f, 0.0f));



```

使用投影矩阵

```c++


glm::mat4 trans = glm::mat4(1.0f);
trans = glm::translate(trans, glm::vec3(1.0f, 0.0f, 0.0f));
glm::mat4 viewMat = glm::mat4(1.0f);
viewMat = glm::translate(viewMat, glm::vec3(0.5f, 0.0f, 0.0f));

```

运行程序，我们会发现所经过的变换是一致。

接下来，我们做一些测试，去尝试找寻观察矩阵的中心点。









