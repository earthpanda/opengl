## 三维矩阵在opengl中的应用

### opengl中的坐标介绍

#### opengl中的窗口坐标

![](img/xy_window.png)

在opengl中我们所看到窗口如上图所示，是一个以中心为坐标原点，x和y分别从-1到1的一个笛卡尔坐标系。也就意味着，后续我们所讨论的坐标系的范围是[-1,1]

也许，大家在查看其它介绍opengl的书中，经常会有这样的说明，首先我们建立一个长为1920 宽为 1080的窗口，这句话的意思是说，把屏幕 1920 * 1080个像素点映射到 [-1,1] 这个范围内。也正因为如此，这样的窗口坐标，我们称之为 设备化标准坐标系

#### opengl 中的纹理坐标系

![](img/tex_coords.png)

纹理坐标系是一个以左下角为原点，取值范围[0,1]的坐标系

### 窗口坐标系如何和纹理坐标系的关系

$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0\\
 -1.0 & -1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0 & 0.0\\
 1.0 & -1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 0.0\\
 1.0 & 1.0 & 0.0 & 0.0 & 0.0 & 0.0 & 1.0 & 1.0
 
}
\right]
$$

这是一个 4 * 7 的矩阵 ，接下来我们对于该矩阵的定义做一个说明 (矩阵的定义可以由开发者自行定义，这里采用的是比较传统普遍的定义方式) 

我们可以把这个矩阵看成是由三部分组成，当然这样写只是为了说明方便,实际上这样的表述是错误的:
$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 \\
 -1.0 & -1.0 & 0.0 \\
 1.0 & -1.0 & 0.0 \\
 1.0 & 1.0 & 0.0 
 
}
\right]
\left[
\matrix{
 0.0 & 0.0 & 0.0 \\
  0.0 & 0.0 & 0.0\\
 0.0 & 0.0 & 0.0\\
  0.0 & 0.0 & 0.0
 
}
\right]


\left[
\matrix{
0.0 & 1.0\\
0.0 & 0.0\\
1.0 & 0.0\\
1.0 & 1.0}
\right]
$$
首先我们要解释下这样的一个矩阵的行和列所代表的意义。

行代表物体的一个顶点的综合信息，由于我们绘制的是一个矩形，因而使用4个顶点便可以正确表示(实际在正确的绘制方式之中，由于是以三角形绘制的，需要6个顶点，这里不展开叙述)，由于在图形学中逆时针代表正向，后续所有讨论的顺序，均以该顺序作为标准。

列代表该顶点的一个属性, 可以看到这个矩阵一共有8列，每列分别代表

ox,oy,oz,r,g,b,tx,ty

ox：物体的x轴坐标

oy：物体的y轴坐标

oz:   物体的z轴坐标

r ： 物体的颜色r通道

g :    物体的颜色g通道

b：物体的颜色b通道

tx：纹理x坐标

ty：纹理y坐标

我们回过头看下前面叙述的设备化标准坐标系和纹理坐标系，就可以得到第一行所代表的意义
$$
\left[
\matrix{
 -1.0 & 1.0 & 0.0 \\
 }
\right]
$$
物体的左上角顶点和窗口的左上角顶点重合
$$
\left[
\matrix{
 0.0 & 0.0 & 0.0 \\
 }
\right]
$$
该顶点颜色为黑色,alpha信息该矩阵并没有给出，一般该属性会在glsl中进行定义
$$
\left[
\matrix{
0.0 & 1.0\\
}
\right]
$$
该顶点所对应的纹理坐标是(0.0,1.0) 也就是图片的左上角。

同理，其它几行也可以有类似的解释，读者可以尝试自行解释下。

ps: 运行程序看下效果.

#### opengl中 图片的旋转 缩放 位移

我们看一下我们设置的window属性 1920 * 1080 

图片的属性 800 * 600 , 如果 按上述的方式设置，则意味着刚开始我们就对图片进行了拉伸使之铺满全屏,如果我们希望得到的效果是 

图片没有拉伸然后展示在图片的中心 或者 左上角，我们如何处理比较合适。

在解决这个问题之前，首先我们要确定一些东西，就是在opengl中，如果我们进行一个旋转，缩放，位移，那么它是什么东西作为参照物的。

在opengl中，我们常用类似于这样的方式进行物体的旋转，缩放和位移

```c++
glm::mat4 trans = glm::mat4(1.0f);
trans = glm::scale(trans, glm::vec3(0.5f, 0.5f, 0.5f));
trans = glm::translate(trans, glm::vec3(1.0f, 0.0f, 0.0f));
trans = glm::rotate(trans, glm::radians(45.0f), glm::vec3(1.0f, 0.0f, 0.0f));
```

上面的程序代表一个变化矩阵，如果大家还记得上一讲的内容，还记得这样的一个公式

M3 * M2 * M1 * V =（M3 * M3 * M1） * V

它意味着一个物体在坐标系中的运算，可以看成是物体经过M1，M2，M3三次变换，或者是先把变换进行求积，然后让物体进行一次变换。

在现在的场景中，V 就是我们上面的4*7 矩阵(确切的说是，该矩阵中和坐标有关系的部分)，M3 * M2 * M1 可以看成是trans 发生的一系列变化。

不知道大家看到这个公式后，直观上有哪些疑问？我这边直观的疑问是

1. 该变换所依赖的重心点是什么
2. 每个vec3中所代表的float的定义是什么
3. 如果运算顺序发生改变，我们所得到的结果是什么

为了回答这样的问题，我们做些简单的实验:

#### 原图

![原图](img\origin.bmp)

#### 只有scale

![s](img/s.bmp)

只有Translate

![](img/t.bmp)

#### 只有rotate

![](img/r.bmp)















